---
layout: post
category: Practicing Ruby
---
尽管我们知道了module作为命名空间的重要用途，但是那只是modules功能的一部分。module最棒的地方是提供了边界方法让开发者可以将不同的对象混合在一起，从而放大他们的行为。因为modules的方便了代码共享，共享的方法既不同于一般的类继承的OO概念，也不同于Java的接口。这就要求你，去以不同于其他面向对象语言的眼光看到它。
这里我就假设大部分读者都能习惯接受mixins，在讲解比较细小微妙的点之前，我会使用Ruby一些核心的mixins去展示他的功能。例如，看一下下面的代码，简单的执行计算：
```ruby
class Computation
	def initialize(&block)
		@action = block
	end

	def result
		@result ||= @action.call
	end

	def <(other)
		@result < other.result
	end

	def >(other)
		@result > other.result
	end

	def >=(other)
		result >= other.result
	end

	def <=(other)
		result <= other.result
	end

	def ==(other)
		result == other.result
	end
end

a = Computation.new { 1+1 }
b = Computation.new { 4*5 }
c = Computation.new { -3 }

p a < b
p a <= b
p b > c
p b >= c
p a == b
```
尽管Ruby使定义特定操作符变的容易，但是这里有些冗余，有些不需要代码：
```ruby
class Computation
	include Comparable

	def initialize(&block)
		@action = block
	end

	def result
		@result ||= @action.call
	end

	def <==>(other)
		return 0 if result == other.result
		return 1 if result > other.result
		return -1 if result < other.result
	end
end

a = Computation.new { 1+1 }
b = Computation.new { 4*5 }
c = Computation.new { -3 }

p a < b
p a <= b
p b > c
p b >= c
p a == b
```
我们看到，以前分着的操作符定义消失了，被两段代码代替。第一处只是加载的表述，告诉Ruby将`Comparable`的功能混入`Computation`类定义中。但是为了使用这个mixin，我们需要告诉`Comparable`怎样去执行`Computation`对象的排序，也就是`<=>`进入的地方了。
这个`<=>`方法，有的时候成为飞船操作符，本质上是填入一个模板方法，使`Comparable`生效。它将大小比较的概念编写成一个抽象的方法，如果现有对象小于参数对象，返回-1,相等返回0,大于返回1。
如果现在还有点困惑，可以假设我们使用的不是Ruby核心对象，我们自己写如下代码然后执行：
```ruby
module Comparable
	def ==(other)
		(self <=> other ) == 0
	end

	def <(other)
		(self <=> other ) == -1
	end

	def <=(other)
		(self <=> other || self == other)
	end

	def >(other)
		(self <=> other ) == 1
	end

	def >=(other)
		self > other || self == other
	end
end
```