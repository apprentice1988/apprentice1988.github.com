---
layout: post
category: Practicing Ruby
---
Modules可以美化Ruby设计。但是，因为在主流的编程语言中没有直接的类比，很多人容易困惑他们到底该如何使用。基本上只有非常有经验的Ruby开发者知道他们真正的用途。
####用于命名空间
假设你正在写一个生成XML的库，在里面，你有一个生产XML文件的类。也许很无创意的，你选择了`Document`作为你的类名，创建如下代码：
```ruby
class Document
	def generate
		# ...
	end
end 
```
就其本身而言，很多道理;一个用户可以简单的使用这个库：
```ruby
require 'your_xml_lib'
document = Document.new
# do something with document
puts document.generate
```
但是设想一下，你正在使用另一个生成PDF文件的库，库里碰巧也使用了同样毫无创意的类名`Document`去生成PDF文件。然后，下面的代码看上去同样有效：
```ruby
require 'their_pdf_lib'
document = Document.new
# do something with document
puts document.generate
```
只要两个库不同时引用，这就没什么问题。但是只要有人引用了两个库，那么就会发生一些让人困惑的结果。有些人可能会认为定义两个相同名字的不同类会导致Ruby产生错误，但是对于公开类，这个情况是不会发生的。Ruby实际上会一个接一个的去应用`Document`的定义，那些最后加载的将有优先性。这个结果很可能产生一个坏掉的`Document`类，既不能产生XML也不能产生PDF。
如果能考虑到命名空间的问题，那么没有理由发生这类问题。下面的代码将使两个`Document`类和平共存。
```ruby
# somewhere in your_xml_lib

module XML
	class Document
		# ...
	end
end

# somewhere in there_pdf_lib
module PDF
	class Document
		# ...
	end
end
```
引用每个库中`Document`时明确的加入命名空间，在一个应用中就不会不出现问题。
```ruby
require "your_xml_lib"
require "their_pdf_lib"

# this pair of calls refer to two completely different classes
pdf_document = PDF::Document.new
xml_document = XML::Document.new
```
每个库都将`Document`类嵌套在里面，使类可以在命名空间中被定义，解决了这个命名冲突的问题，但是这是一个相对直接的概念，我们仍要注意在运行方面的一些细节。
首先，命名空间实际应用于常量在Ruby中查询的途中，而不是类中。这意味着module嵌套module和嵌套普通的常量一样。
```ruby
module A
	module B
	end
end

p A::B

module A
	C = 10
end

p A::C
```
第二点，类嵌套和使用module嵌套会产生相同的效果，如下：
```ruby
class Blog
	class Comment
	  # ...
	end
end
```
一定要明确一点，类嵌套不会产生子类或者两类之间除了命名空间外的任何关系。下面的例子，你可以把类嵌套看作类嵌套在module中
```ruby
blog = Blog.new
comment = Blog::Comment.new
# ...
```
当然，这个技术只有在你想要的命名空间正好与你的类名字相符的时候才有用。其他的任何情况，使用module作为命名空间将更有道理，可以防止你的用户生成一个空的实例或者无意义的类。

最后，理解常量由内到外的查询也是很重要的，最后查询全局命名空间。这个有的时候会有点困惑，尤其当你在解决比较偏的案例时。
例如，我们来看一下下面的代码：
```ruby
module FancyReporter
	class Document
		def initialize
			@output = String.new
		end

		attr_reader :output
	end
end
```
如果你将这个代码在irb中运行，你可以查看`Document`实例的output的属性是`String`，如下：
```bash
>> FancyReporter::Document.new.output
=> ""
>> FancyReporter::Document.new.output.class
=> String
```
很显而易见，写在其他很不相关的代码很容易改变所有事情，看一下下面的代码：
```ruby
module FancyReporter
	module String
		class Formatter
		end
	end
end
```
这个`FancyReporter`的设计师希望通过提供`FancyReporter::String::Formatter`,很好的组织这个module，但是这样小小的改变产生了令人头疼的问题，因为它改变了在`Document`的初始化方法中的`String.new`的含义。事实上，你现在无法创建`Document`的实例，会产生如下错误：
```bash
?> FancyReporter::Document.new
NoMethodError: undefined method 'new' for FancyReporter::String:Module
	from (irb):35:in 'initialize'
	from (irb):53:in 'new'
	from (irb):53
```
有几个方法可以避免这个错误。经常用到的是想出一些可以替换的命名，使其不予核心对象命名冲突，如果能这样，那就是最后的。在一起特别的情况下，`String.new`也可以使用`“”`替换。但是这里还有另一个方法，独立于现在的环境，就是明确的使用全局命名中的常量查询。如下：
```ruby
module FancyReporter
	class Document
		def initialize
			@output = ::String.new
		end

		attr_reader :output
	end
end
```
在任何常量前面加上`::`将强制Ruby跳过嵌套的命名空间直接跳到最上层。按这个道理，`A::B`和`::A::B`的区别是前者是相对查询，而后者是从根命名空间中查找的绝对路径。
一般情况下，不得不使用绝对查询是你的应用中存在不必要的命名冲突的征兆。但是如果你通过研究发现命名继承过程中雨其他的有冲突，可以使用这个方法避免冲突。
####滥用常量查询符(`::`)
在一些老的文档中，或者一些从老文档中学来的代码中，你可以类方法被如下调用：
`ruby
YAML::load(File::read("foo.yaml"))
```
尽管上面的代码运行正常，但他只是历史巧合。事实上，`::`从未被用来调用方法，包括类方法或者其他。你可以很容易的证明`::`可以被用来执行实例方法，这样消除了`::`有一些雷锋那个发特别用法的说法。
```ruby
"foo"::reverse #=> "oof"
```
据我所知，这类方法调用的风格出自文件配置。无论在正式的文件，还是在邮件列表讨论中，很难去分辨一个人讨论的是一个类方法还是一个实例方法，因为两者都可以用点操作符来操作。所以，一个约定就悄然而生，实例方法使用`Foo#bar`,类方法使用`Foo::bar`.这样很清晰的区分开类方法和实例方法。

不幸的是，这导致了让人困惑的情况。初学者经常使用`Foo#bar`调用实例方法，但是很快收到教训，这个的调用不可用。但是，输入`Foo::bar`,可以使用！所以，一代代的Ruby开发者都认为`::`是调用类方法的特别符号，一定程度上，后来者跟着就适应了这个约定。
事实上，`::`调用方法是要涉及MRI内部操作细节，所以它是未被定义的行为，需要被改变。据我所知，这种调用是不保证以后也可以使用的。

在你的代码中，你应该自由的使用点操作符，例如`Foo.bar`.这样更能反映Ruby的本质，这种操作不强调类方法和实例方法的区别。因为这种区别不重要。但是文件中，事情有点复杂，但是现在普遍接受`Foo.bar`指代类方法，`Foo#bar`指代实例方法。以后尽量使用`Foo.bar`,不要去使用`Foo::bar`,这样，一个统一的标准才会产生，这个理由够充分，放弃过时的操作吧。