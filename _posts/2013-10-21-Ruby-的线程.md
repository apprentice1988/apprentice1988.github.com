---
layout: post
category: Piecemeal Ruby
---

Ruby 有很多非常酷的特征，例如可以在运行时创建类，变化某些对象的行为，使用 ObjectSpace 监视内存中类的数量，还有许多测试套件。这些都简化了开发者的工作。今天，我们将讨论在计算科学中一个很基本的概念：线程和Ruby如何支持线程的。

#### 介绍
首先，让我们定义一下线程。维基百科的解释是：
> 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程(kernel thread)，而把用户线程(user thread)称为线程。

一个线程是一个轻量级的进程。同一个进程中的多个线程共用进程中的资源。所以在一些场合多线程是比较经济的选择。

我们来看一下多线程的用处。

#### 基本的例子

```ruby
def calculate_sum(arr)
	sum = 0
	arr.each do |item|
		sum += item
	end
	sum 
end

@items1 = [12,34,55]
@items2 = [45, 90,2]
@items3 = [99, 22,31]

puts "items1 = #{calculate_sum @items1}"
puts "items2 = #{calculate_sum @items2}"
puts "items3 = #{calculate_sum @items3}"
```
输出结果：

```
items1 = 101
items2 = 137
items3 = 152
```

这是一个很简单的例子帮助我们理解为什么使用线程。在上面的代码列表中，我们有三个数组计算综合。 三个过程都使很直接的，无依赖的。但是，其中的一个问题是，我们无法在得到`items1`结果之前得到 `items2`的结果。同样 `items3`是最后得到的结果。让我们改变一下代码：

```ruby
def calculate_sum(arr)
	sleep(2)
	sum = 0
	arr.each do |item|
		sum += item
	end
	sum
end
```

上面的代码列表，我们添加了 `sleep(2)` 使每一个求和过程中间暂停两秒。这就意味着 `items1`的求和需要2s的暂停，`items2`的求和过程中有4s（2s+2s)的暂停，以此类推。这样不是我们想要的情况，因为这样的执行效率很低。

我们的数组求和都使彼此分离的，所以我们分别独立的求各自的结果会比较理想。这个时候线程的概念就来的很及时了。

我们来把上面的代码用多线程的方法重构一下：

```ruby
def calculate_sum(arr)
  sleep(2)
  sum = 0
  arr.each do |item|
    sum += item
  end
  sum
end

@items1 = [12,34,55]
@items2 = [45,90,2]
@items3 = [99,22,31]

threads = (1..3).map do |i|
	Thread.new(i) do |i|
		items = instance_variable_get("@items#{i}")
		puts "items#{i} = #{calculate_sum(items)}"
	end
end
theads.each {|t| t.join}
```
这个`calculate_sum`方法和我们之前的方法一样，添加了 `sleep(2)`. 我们的数组也是相同的。最重要的变化是我们在每一个数组上调用了 `calculate_sum`。我们将方法和数组整合在一个 `Thread.new`的代码块中。这是Ruby使用线程的方法。

运行上面的代码，你会发现，三个数组求和的结果不是一个一个出现的，而是暂停了2s后几乎同时得到了三个数组的结果。

```
items2 = 137
items3 = 152
items1 = 101
```

#### 竞态条件
每一个特性的实现都伴随着代价。多线程很好，但是在写多线程应用时，要格外小心对于竞态条件的操作。什么是竞态条件？一下是维基百科的解释：
> 当分散的电脑处理进程或者执行的线程共用一些资源时，就会出现竞态条件。对于共享条件的操作是很重要的部分，必须做到互斥。如果不能做到这一原则，就会有崩溃的可能。

简单来说，如果我们有一些共享的数据可以被多线程取用，那么当线程进行完后，我们的数据应该依然是好的。

```ruby
class Item
	class << self; attr_accessor :price end
	@price = 0
end

(1..10).each {|Item.price += 10}
puts "Item.price = #{Item.price}"
```

我们构造了一个简单的`Item`类，它有一个类变量 `price`。 `Item.price`在迭代中会自动增加。运行以上代码，将得到结果：

```
Item.price = 100
```

现在我们将以上代码重构成多线程的版本：

```ruby
class Item
  class << self; attr_accessor :price end
  @price = 0
end

threads = (1..10).map do |i|
	Thread.new(i) do |i|
		item_price = Item.price
		sleep(rand(0..2))
		item_price += 10
		sleep(rand(0..2))
		Item.price = item_price
	end
end

threads.each {|t| t.join}
puts "Item.price = #{Item.price}"
```

`Item`类还是一样的，但是我们改变了增加 `price`值的方法。我们特意在代码中使用了`sleep`来更加容易的显现出并发造成的问题。对运行几次代码，你会发现两个事情。
首先是结果是不准确，不固定的。结果不再是100,可能是30,40,70等等。这就是竞态条件的结果。没运行一次程序，都有会卡掉崩溃的情况。

#### 互斥
为了修复竞态条件，我们必须控制程序，使其一个线程工作的时候，其他线程排队等候。这就叫做互斥。我们利用这个概念消除竞态条件。

Ruby提供了很好用的互斥方法：

```ruby
class Item
	class << self; attr_accessor :price end
	@price = 0
end

mutex = Mutex.new

threads = (1..10).map do |i|
  Thread.new(i) do |i|
  	mutex.synchronize do 
  		item_price = Item.price
  		sleep(rand(0..2))
  		item_price += 10
  		sleep(rand(0..2))
  		Item.price = item_price
  	end
  end
end

threads.each {|t| t.join}
puts "Item.price = #{Item.price}"
```

运行代码输出结果：

```
Item.price = 100
```

这是因为`mutex.synchronize`. 一个且只有一个可以进入外包有 `mutex.synchronize`的代码块。