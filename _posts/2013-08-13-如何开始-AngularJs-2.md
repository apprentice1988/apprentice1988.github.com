---
layout: post
category: Angular-Js
---
#### 第二部分：Scopes
一个`$scope`是一个链接view到控制器的物件。 在MVC框架中，这`$scope`就扮演了Model。提供了一个运行在DOM元素中的执行文件。

尽管听起来有些复杂， 但是`$scope`只是一个javascript物件。因为控制器和页面都能获取`$scope`，所以它可以被用来作为纽带。`$scope`可以为我们提供数据和方法供我们在页面中使用，就像下面将看到的那样。

所有AngularJS 应用都有一个`$rootScope`。 这个`$rootScope`是一个最高级别的scope，包含`ng-app`目录。

在这个例子中， 我们运用了`$rootScope`。我们在`main.js`文件中为scope添加了一个`name`属性。通过把这个方法放入`app.run`方法中，我们可以保证它将先于应用的其他部分执行。 你可以把`run`方法想成angular应用的main方法。

```javascript
app.run(function($rootScope) {
	$rootScope.name = "Ari Lerner";
})
```
现在，我们可以在我们页面的任何地方，使用模板去引用这个属性：{{}}， 如下：

```html
{{name}}
```

#####See it:
{{aPersonname}}

总结：
* 我们附加在`$scope`事物上的任何东西都可以在view页面中使用。
* 在控制器中的改变会在view页面中显示出来。
为了真实的看到scopes的效果，我们将一个控制器关联到Dom元素，这样将创建一个元素的`$scope`，允许我们与之互动。

#####ng-controller
为了明确地创建一个`$scope`事物，我们将一个控制器使用`ng-controller`目录关联在元素上，像这样：
```html
<div ng-controller="MyController">
	{{ person.name }}
</div>
```

这个	`ng-controller`目录为该Dom元素创建一个新的`$scope`事物，并将它嵌在显存的`$scope`中。在这个例中，附带`ng-controller`的`div`元素的父`$scope`是`$rootScope`事物。
现在，`MyController`设置了一个`$scope`,我们可以在Dom内部调用。在这个例子中，我们在MyController的`$scope`中创建一个`person`事物，在main.js中：

```javascript
app.controller('MyController', function($scope) {
	$scope.person = {
		name: "Ari Lerner"
	};
});
```
现在，我们可以在任何标有`ng-controller='MyController'的`div`子元素中获取这个`person`事物。

#####See it：
Ari Lerner

除了一个例外，所有的scopes都伴随着原型继承，意味着他们可以去到parent scopes。默认的，一个属性在现在的范围中查询不到会自动进入包含它的scope中继续查询，直到达到`$rootScope`.
> 一个例外： 一些目录选择性的创建了隔离scope，不从他们的父类中继承。
例如，假设我们有一个包含`user`对象的`ParentController`，同时`ChildController`想要引用这个对象：
```javascript
app.controller('ParentController', function($scope) {
	$scope.person = {greeted: false};
});

app.controller('ChildController', function($scope) {
	$scope.sayHello = function() {
	$scope.person.greeted = true;
	}
});
```
当我们在view页面中将`ChildController`捆绑在`ParentController`下时，我们可以直接引用父类中的原型：
```html
<div ng-controller = "ParentController">
	<div ng-controller = "ChildController">
		<input type="text" ng-model = "person.name" placeholder="Name"></input>
		<a ng-click="sayHello()">Say hello</a>
	</div>
	{{ person }}
</div>
```
####集成在应用中
现在让我们使用`$scope`的用途来管理我们的NPR应用。我们在上一篇文章中已经定义了app module。现在让我们打散我们的Dom结构，创建我们基本的功能。
就像上面看到的例子那样，我们将创建一个根控制器`PlayerController`。我们的`PlayerController`将负责跟踪我们的audio并且处理返回的我们的NPR应用的列表。
我们在`main.js`中创建两个控制器：

```javascript
var app = angular.module('MyApp',[]);
app.controller('PlayerController',['$scope',function($scope){}]);
app.controller('RelatedController',['$scope',function($scope){}]);
```
#####Audio
现在的控制器什么也不能进行，所以让我们添加一些audio在应用中。
为了添加audio，我们既可以在HTML文件中操作，也可以在控制器中操作。因为我们主要在我们的控制器中与audio互动，所以在控制器中创建他将更合适。
在我们的`PlayController`中，让我们创建audio元素。我们将储存在我们的scope中，如你所知，这意味着我们要使用`$scope`对象在view页面中连接控制器。

```javascript
app.controller('PlayerController',['$scope',function($scope){
	$scope.audio = document.createElement('audio');
}]);
```
现在，我们的设置有些枯燥，因为什么功能也不能实现。我们在下一节会涉及取数据的方法，所以现在我们需要手动输入`.mp4`地址。
在这相同的`PlayerController`，设置我们`.mp4`文件的获取地址。为了方便，我们使用我们主机的NPR的录音文件，其实我们可以指向任何地址。

```javascript
app.controller('PlayerController',['$scope', function($scope){
	$scope.playing = false;
	$scope.audio = document.createElement('audio');
	$scope.audio.src = "/media/npr.mp4";
}]);
```
这个录音只有在你要求播放的时候才会播放。为了使其播放，我们可以简单的调用`$scope.audio.play()`方法，HTML5会接管开始通过mp4流去播放。
我们可以通过创建一个按键，将这个动作绑定在`$scope`上来实现和该录音的交互。

```html
<div ng-controller="PlayerController">
	<button ng-click="play()" class="button" ng-show="!playing">Play</button>
	<button ng-click="stop" class="button alert" ng-show="playing">Stop</button>
	Playing audio: <b>{{ playing }}</b>
</div>
```
我们已经添加了一些变量在view页面，跟踪`$scope`.

```javascript
app.controller('PlayerController',['$scope',function($scope){
	$scope.playing = false;
	$scope.audio = document.createElement('audio');
	$scope.audio.src = "/media/npr.mp4";
	$scope.paly = function(){
		$scope.audio.play();
		$scope.playing = true;
	};
	$scope.stop = function() {
		$scope.audio.pause();
		$scope.playing = false;
	};
	$scope.audio.addEventListener('ended',function(){
		$scope.$apply(function(){
			$scope.stop()
		});
	});
}]);
```
这里我们介绍了`$scope`服务。在下面的部分中，我们还将涉及双向的数据绑定问题。